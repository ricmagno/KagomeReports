/**
 * Step by Step PDF Test
 * Test each part of the PDF generation process individually
 */

import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';

// Mock the environment and logger
jest.mock('@/config/environment', () => ({
  env: {
    REPORTS_DIR: './test-reports',
    NODE_ENV: 'test',
    LOG_FILE: './test-logs/app.log',
    LOG_LEVEL: 'info',
    LOG_MAX_SIZE: '10m',
    LOG_MAX_FILES: 5
  }
}));

jest.mock('@/utils/logger', () => ({
  reportLogger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn()
  }
}));

import { ReportGenerationService, ReportConfig, ReportData } from '@/services/reportGeneration';
import { TimeSeriesData } from '@/types/historian';

describe('Step by Step PDF Generation', () => {
  let service: ReportGenerationService;

  beforeAll(() => {
    const testReportsDir = './test-reports';
    if (!fs.existsSync(testReportsDir)) {
      fs.mkdirSync(testReportsDir, { recursive: true });
    }
  });

  beforeEach(() => {
    service = new ReportGenerationService();
  });

  it('should create PDF document without errors', (done) => {
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 50, bottom: 50, left: 50, right: 50 }
    });

    const chunks: Buffer[] = [];
    doc.on('data', chunk => chunks.push(chunk));
    doc.on('error', (error) => {
      console.error('PDF Document error:', error);
      done(error);
    });
    
    doc.on('end', () => {
      const buffer = Buffer.concat(chunks);
      expect(buffer.length).toBeGreaterThan(0);
      done();
    });

    // Test the same operations as in ReportGenerationService
    try {
      // Test header
      doc.rect(0, 0, doc.page.width, 80).fill('#0ea5e9');
      doc.fillColor('white').fontSize(20).font('Helvetica-Bold').text('Test Company', 50, 25);
      doc.fillColor('black');
      doc.y = 100;

      // Test title
      doc.fontSize(24).font('Helvetica-Bold').text('Test Report', { align: 'center' });
      doc.moveDown();

      // Test time range with dates
      const startTime = new Date('2024-01-01T00:00:00Z');
      const endTime = new Date('2024-01-01T01:00:00Z');
      
      if (startTime instanceof Date && endTime instanceof Date) {
        const startStr = startTime.toLocaleString();
        const endStr = endTime.toLocaleString();
        doc.fontSize(12).text(`Report Period: ${startStr} - ${endStr}`, { align: 'center' });
      }
      
      doc.moveDown(2);

      // Test metadata
      const generatedAt = new Date();
      const generatedStr = generatedAt instanceof Date ? generatedAt.toLocaleString() : 'Unknown';
      
      doc.fontSize(10).font('Helvetica-Bold').text('Generated:', 50, doc.y);
      doc.font('Helvetica').text(generatedStr, 120, doc.y);
      doc.moveDown();

      // Test data section
      const testData: TimeSeriesData[] = [
        {
          tagName: 'TEST_TAG',
          timestamp: new Date('2024-01-01T00:00:00Z'),
          value: 100,
          quality: 192
        }
      ];

      doc.fontSize(18).font('Helvetica-Bold').text('Tag: TEST_TAG');
      doc.moveDown();
      doc.fontSize(12).font('Helvetica').text(`Data Points: ${testData.length}`);
      
      if (testData.length > 0) {
        const firstTime = testData[0]?.timestamp?.toLocaleString() || 'Unknown';
        const lastTime = testData[testData.length - 1]?.timestamp?.toLocaleString() || 'Unknown';
        doc.text(`Time Range: ${firstTime} - ${lastTime}`);
      }

      // Test footer
      doc.strokeColor('#cccccc').lineWidth(1)
         .moveTo(50, doc.page.height - 50)
         .lineTo(doc.page.width - 50, doc.page.height - 50)
         .stroke();

      doc.fillColor('#666666').fontSize(8)
         .text(`Generated by Test on ${generatedStr}`, 50, doc.page.height - 40, { align: 'left' });

      doc.end();
    } catch (error) {
      console.error('Error during PDF creation:', error);
      done(error);
    }
  });

  afterAll(() => {
    const testReportsDir = './test-reports';
    if (fs.existsSync(testReportsDir)) {
      try {
        const files = fs.readdirSync(testReportsDir);
        files.forEach(file => {
          fs.unlinkSync(path.join(testReportsDir, file));
        });
        fs.rmdirSync(testReportsDir);
      } catch (error) {
        console.warn('Failed to clean up test directory:', error);
      }
    }
  });
});