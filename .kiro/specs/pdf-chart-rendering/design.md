# Design Document: PDF Chart Rendering Fix

## Overview

This design addresses the issue where charts generated by Chart.js are not appearing in PDF reports created by PDFKit. The solution involves adding comprehensive validation, logging, and error handling throughout the chart generation and embedding pipeline.

## Architecture

### Component Interaction

```
┌─────────────────┐
│ Report Request  │
└────────┬────────┘
         │
         v
┌─────────────────────┐
│ Data Flow Service   │
│ - Retrieve data     │
│ - Calculate stats   │
└────────┬────────────┘
         │
         v
┌─────────────────────┐
│ Chart Generation    │
│ - Create canvas     │
│ - Render Chart.js   │
│ - Export PNG buffer │
└────────┬────────────┘
         │
         v
┌─────────────────────┐
│ Buffer Validation   │ ← NEW
│ - Check PNG header  │
│ - Verify size       │
│ - Log details       │
└────────┬────────────┘
         │
         v
┌─────────────────────┐
│ PDF Generation      │
│ - Embed charts      │
│ - Handle errors     │
│ - Add fallbacks     │
└────────┬────────────┘
         │
         v
┌─────────────────┐
│ PDF Document    │
└─────────────────┘
```

## Components and Interfaces

### 1. Chart Buffer Validator

**Purpose**: Validate chart buffers before PDF embedding

**Interface**:
```typescript
interface ChartBufferValidator {
  validateBuffer(buffer: Buffer, chartName: string): ValidationResult;
  isPNGBuffer(buffer: Buffer): boolean;
  getBufferInfo(buffer: Buffer): BufferInfo;
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  bufferInfo: BufferInfo;
}

interface BufferInfo {
  size: number;
  format: string;
  dimensions?: { width: number; height: number };
}
```

**Implementation**:
```typescript
class ChartBufferValidator {
  private readonly PNG_MAGIC_BYTES = Buffer.from([0x89, 0x50, 0x4E, 0x47]);
  private readonly MIN_BUFFER_SIZE = 100; // bytes
  private readonly MAX_BUFFER_SIZE = 10 * 1024 * 1024; // 10MB

  validateBuffer(buffer: Buffer, chartName: string): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check buffer exists and has content
    if (!buffer || buffer.length === 0) {
      errors.push(`Chart buffer is empty for ${chartName}`);
      return { valid: false, errors, warnings, bufferInfo: { size: 0, format: 'unknown' } };
    }

    // Check buffer size
    if (buffer.length < this.MIN_BUFFER_SIZE) {
      errors.push(`Chart buffer too small (${buffer.length} bytes) for ${chartName}`);
    }

    if (buffer.length > this.MAX_BUFFER_SIZE) {
      warnings.push(`Chart buffer very large (${buffer.length} bytes) for ${chartName}`);
    }

    // Check PNG format
    if (!this.isPNGBuffer(buffer)) {
      errors.push(`Chart buffer is not valid PNG format for ${chartName}`);
    }

    const bufferInfo = this.getBufferInfo(buffer);

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      bufferInfo
    };
  }

  isPNGBuffer(buffer: Buffer): boolean {
    if (buffer.length < 8) return false;
    return buffer.slice(0, 4).equals(this.PNG_MAGIC_BYTES);
  }

  getBufferInfo(buffer: Buffer): BufferInfo {
    return {
      size: buffer.length,
      format: this.isPNGBuffer(buffer) ? 'PNG' : 'unknown'
    };
  }
}
```

### 2. Enhanced Chart Generation Service

**Modifications to `chartGenerationService`**:

```typescript
async generateLineChart(
  datasets: LineChartData[],
  options: ChartOptions = {}
): Promise<Buffer> {
  const width = options.width || this.defaultWidth;
  const height = options.height || this.defaultHeight;
  
  try {
    reportLogger.info('Generating line chart', { 
      datasets: datasets.length,
      width,
      height,
      dataPoints: datasets.reduce((sum, d) => sum + d.data.length, 0)
    });

    // Validate input data
    if (datasets.length === 0 || datasets.every(d => d.data.length === 0)) {
      throw new Error('No data available for chart generation');
    }

    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // ... existing chart configuration ...

    // Create chart
    const chart = new Chart(ctx, config);

    // Convert to buffer with error handling
    let buffer: Buffer;
    try {
      buffer = canvas.toBuffer('image/png');
    } catch (error) {
      reportLogger.error('Failed to convert canvas to buffer', { error });
      throw new Error(`Canvas to buffer conversion failed: ${error.message}`);
    }

    // Validate buffer
    const validator = new ChartBufferValidator();
    const validation = validator.validateBuffer(buffer, 'line_chart');
    
    if (!validation.valid) {
      reportLogger.error('Generated chart buffer is invalid', {
        errors: validation.errors,
        bufferInfo: validation.bufferInfo
      });
      throw new Error(`Invalid chart buffer: ${validation.errors.join(', ')}`);
    }

    if (validation.warnings.length > 0) {
      reportLogger.warn('Chart buffer validation warnings', {
        warnings: validation.warnings
      });
    }

    // Clean up
    chart.destroy();

    reportLogger.info('Line chart generated successfully', {
      bufferSize: buffer.length,
      format: validation.bufferInfo.format,
      dataPoints: datasets.reduce((sum, d) => sum + d.data.length, 0)
    });

    return buffer;
  } catch (error) {
    reportLogger.error('Failed to generate line chart', { 
      error: error.message,
      stack: error.stack,
      datasets: datasets.length
    });
    throw error;
  }
}
```

### 3. Enhanced PDF Chart Embedding

**Modifications to `reportGenerationService.addChartsSection`**:

```typescript
private addChartsSection(doc: PDFKit.PDFDocument, charts: Record<string, Buffer>): void {
  doc.fontSize(18)
     .font('Helvetica-Bold')
     .text('Data Visualizations');

  doc.moveDown();

  const validator = new ChartBufferValidator();
  let chartCount = 0;
  let successCount = 0;
  let failureCount = 0;
  const failures: string[] = [];

  for (const [chartName, chartBuffer] of Object.entries(charts)) {
    if (chartCount > 0 && chartCount % 2 === 0) {
      doc.addPage();
    }

    const y = doc.y;
    const chartWidth = 450;  // Increased from 250
    const chartHeight = 300; // Increased from 200

    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text(chartName, { align: 'center' });

    doc.moveDown();

    // Validate buffer before embedding
    const validation = validator.validateBuffer(chartBuffer, chartName);
    
    if (!validation.valid) {
      reportLogger.error('Chart buffer validation failed', {
        chartName,
        errors: validation.errors,
        bufferInfo: validation.bufferInfo
      });
      
      // Add placeholder text
      doc.fontSize(12)
         .font('Helvetica')
         .fillColor('#ef4444')
         .text(`Chart could not be displayed: ${validation.errors[0]}`, { 
           align: 'center',
           width: chartWidth
         })
         .fillColor('black');
      
      failures.push(chartName);
      failureCount++;
    } else {
      try {
        // Log buffer details before embedding
        reportLogger.debug('Embedding chart in PDF', {
          chartName,
          bufferSize: validation.bufferInfo.size,
          format: validation.bufferInfo.format,
          dimensions: { width: chartWidth, height: chartHeight }
        });

        // Add chart image with explicit options
        doc.image(chartBuffer, {
          fit: [chartWidth, chartHeight],
          align: 'center',
          valign: 'top'
        });

        successCount++;
        
        reportLogger.info('Chart embedded successfully', {
          chartName,
          bufferSize: validation.bufferInfo.size
        });

      } catch (error) {
        reportLogger.error('Failed to embed chart in PDF', { 
          chartName, 
          error: error.message,
          stack: error.stack,
          bufferSize: validation.bufferInfo.size
        });
        
        // Add error placeholder
        doc.fontSize(12)
           .font('Helvetica')
           .fillColor('#ef4444')
           .text(`Chart embedding failed: ${error.message}`, { 
             align: 'center',
             width: chartWidth
           })
           .fillColor('black');
        
        failures.push(chartName);
        failureCount++;
      }
    }

    doc.moveDown(2);
    chartCount++;
  }

  // Log summary
  reportLogger.info('Chart embedding summary', {
    total: chartCount,
    successful: successCount,
    failed: failureCount,
    failures: failures
  });

  // Add summary note if there were failures
  if (failureCount > 0) {
    doc.moveDown();
    doc.fontSize(10)
       .font('Helvetica')
       .fillColor('#666666')
       .text(`Note: ${failureCount} chart(s) could not be displayed. See logs for details.`, {
         align: 'center'
       })
       .fillColor('black');
  }
}
```

## Data Models

### Chart Metadata

```typescript
interface ChartMetadata {
  name: string;
  type: 'line' | 'bar' | 'trend' | 'scatter';
  tagName: string;
  dataPoints: number;
  generatedAt: Date;
  bufferSize: number;
  dimensions: {
    width: number;
    height: number;
  };
  status: 'success' | 'failed';
  error?: string;
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do.*

### Property 1: Chart Buffer Validity
*For any* generated chart buffer, the buffer must contain valid PNG data with proper magic bytes and non-zero size.
**Validates: Requirements 1.4, 4.1**

### Property 2: Error Handling Continuity
*For any* chart that fails to generate or embed, the system must continue processing remaining charts and generate a complete report.
**Validates: Requirements 3.3, 5.2**

### Property 3: Logging Completeness
*For any* chart operation (generation or embedding), the system must log the operation result with sufficient detail for debugging.
**Validates: Requirements 1.1, 1.2, 3.1, 3.2**

### Property 4: Fallback Behavior
*For any* failed chart embedding, the PDF must contain either a placeholder message or skip the chart with appropriate notation.
**Validates: Requirements 5.1, 5.4**

## Error Handling

### Chart Generation Errors

1. **No Data Available**: Return empty result with warning log
2. **Canvas Creation Failed**: Throw error with detailed message
3. **Chart.js Rendering Failed**: Log error and throw with context
4. **Buffer Conversion Failed**: Log error and throw with canvas state

### PDF Embedding Errors

1. **Invalid Buffer**: Skip chart, add placeholder, log error
2. **PDFKit Image Error**: Skip chart, add placeholder, log error
3. **Memory Issues**: Reduce chart dimensions and retry once
4. **Page Overflow**: Add new page and retry

## Testing Strategy

### Unit Tests

1. Test chart buffer validation with various buffer states
2. Test PNG magic byte detection
3. Test buffer size validation
4. Test error message generation

### Integration Tests

1. Test end-to-end chart generation and embedding
2. Test error recovery with invalid buffers
3. Test PDF generation with mixed success/failure charts
4. Test logging output for all scenarios

### Property-Based Tests

1. Generate random chart data and verify buffer validity
2. Test error handling with randomly injected failures
3. Verify logging completeness across random scenarios

## Implementation Notes

### Debugging Enhancements

1. **Save Chart Buffers**: Optionally save chart buffers to disk for inspection
2. **Verbose Logging**: Add environment variable to enable detailed chart logging
3. **Buffer Inspection**: Add utility to inspect buffer contents and metadata
4. **Test Mode**: Add mode to generate charts without PDF for isolated testing

### Performance Considerations

1. Chart generation is CPU-intensive; consider caching
2. Large buffers may cause memory issues; monitor and limit
3. Multiple charts should be generated in parallel when possible
4. Consider streaming for very large reports

### Configuration

Add environment variables:
- `CHART_DEBUG_MODE`: Enable detailed logging and buffer saving
- `CHART_MAX_BUFFER_SIZE`: Maximum allowed chart buffer size
- `CHART_DEFAULT_WIDTH`: Default chart width
- `CHART_DEFAULT_HEIGHT`: Default chart height
- `CHART_SAVE_TO_DISK`: Save chart buffers to disk for debugging
